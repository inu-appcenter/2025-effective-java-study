# 아이템 14

```java
public class Student implements Comparable<Student>{
    private String name;
    private int grade;
    private double gpa;

    public Student(String name, int grade, double gpa) {
        this.name = name;
        this.grade = grade;
        this.gpa = gpa;
    }

    @Override
    public int compareTo(Student o) {
        int result = Integer.compare(this.grade, o.grade);
        if (result != 0) return result;

        return Double.compare(this.gpa, o.gpa);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", grade=" + grade +
                ", gpa=" + gpa +
                '}';
    }
}

public static void main(String[] args) {
    List<Student> students = new ArrayList<>();
    Student s1 = new Student("a", 3, 3.8);
    Student s2 = new Student("b", 2, 3.9);
    Student s3 = new Student("c", 3, 3.8);
    Student s4 = new Student("d", 2, 3.7);
    students.add(s1);
    students.add(s2);
    students.add(s3);
    students.add(s4);

    Collections.sort(students);

    students.forEach(System.out::println);

}

Student{name='d', grade=2, gpa=3.7}
Student{name='b', grade=2, gpa=3.9}
Student{name='a', grade=3, gpa=3.8}
Student{name='c', grade=3, gpa=3.8}
```

```java
public static void main(String[] args) {
    BigDecimal bigDecimal1 = new BigDecimal("1.0");
    BigDecimal bigDecimal2 = new BigDecimal("1.00");

    System.out.println(bigDecimal1.equals(bigDecimal2));
    System.out.println(bigDecimal1.compareTo(bigDecimal2));

    Set<BigDecimal> hashSet = new HashSet<>();
    hashSet.add(bigDecimal1);
    hashSet.add(bigDecimal2);
    System.out.println("HashSet : "  + hashSet.size());

    Set<BigDecimal> treeSet = new TreeSet<>();
    treeSet.add(bigDecimal1);
    treeSet.add(bigDecimal2);
    System.out.println("TreeSet : " + treeSet.size());
}

false
0
HashSet : 2
TreeSet : 1

차이 이유 : 
equals 는 소수점 스케일까지 비교 1.0, 1.00은 스케일이 다르므로(1, 2) false
compareTo는 수학적으로 비교(1.0 = 1.00)

HashSet은 equals + hashCode로 비교하기 때문에 두 bigDecimal이 다르므로 2개가 저장
TreSet은 compareTo로 비교하기 때문에 두 bigDecimal이 같으므로 중복이 불가능한 Set에선 1개만 저장됨
```

```java
public class Student implements Comparable<Student>{
    private String name;
    private int grade;
    private double gpa;

    public Student(String name, int grade, double gpa) {
        this.name = name;
        this.grade = grade;
        this.gpa = gpa;
    }

    @Override
    public int compareTo(Student other) {
        return this.grade - other.grade;  // 오버플로우 위험!
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", grade=" + grade +
                ", gpa=" + gpa +
                '}';
    }
}

public static void main(String[] args) {
    Student student1 = new Student("1", 1, 1.1);
    Student student2 = new Student("1", 1, 1.1);

    Set<Student> hashSet = new HashSet<>();
    hashSet.add(student1);
    hashSet.add(student2);

    System.out.println(hashSet.size());

    Set<Student> treeSet = new TreeSet<>();
    treeSet.add(student1);
    treeSet.add(student2);

    System.out.println(treeSet.size());
}

2
1

----------

public class Student implements Comparable<Student>{
    private String name;
    private int grade;
    private double gpa;

    public Student(String name, int grade, double gpa) {
        this.name = name;
        this.grade = grade;
        this.gpa = gpa;
    }

    @Override
    public int compareTo(Student other) {
        return this.grade - other.grade;  // 오버플로우 위험!
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", grade=" + grade +
                ", gpa=" + gpa +
                '}';
    }

    @Override
    public boolean equals(Object object) {
        if (object == null || getClass() != object.getClass()) return false;
        Student student = (Student) object;
        return grade == student.grade && Double.compare(gpa, student.gpa) == 0 && Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, grade, gpa);
    }
}

1
1

```

## 핵심 정리

1. **순서가 명확한 값 클래스**라면 반드시 Comparable을 구현하세요
2. **compareTo 규약**을 반드시 지키세요 (대칭성, 추이성, 일관성)
3. *관계 연산자 (<, >)**는 사용하지 말고 **compare 메서드**를 사용하세요
4. **equals와의 일관성**을 유지하세요
5. **Java 8의 비교자 생성 메서드**를 활용하면 더 깔끔한 코드를 작성할 수 있습니다