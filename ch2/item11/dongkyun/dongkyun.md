# item11

## #️⃣ equals를 재정의하려거든 hashCode도 재정의하라

---

- **equals**를 재정의한 클래스 모두에서 **hashCode**도 재정의해야 한다.
    - 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap
      이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.

- **hashCode** 재정의를 잘못했을 때 크게 문제가 되는 조항은 아래와 같다.

  > equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을
  반환해야 한다.
  >
    - 즉, 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다.

    ```java
    // 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하여 두 번째 규약을 지키지 못한다.
    Map<PhoneNumber, String그 m = new HashMapo();
    m. put (new PhoneNumber (707, 867, 5309), "제니");
    
    m. get (new PhoneNumber(707, 867, 5309)) -> null
    ```


- **Objects 클래스**는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 정적 메서드인 `hash`를 제공한다
    - 성능의 아쉬움이 있어, 성능에 민감하지 않은 상황에서만 사용

        ```java
        @Override public int hashCode() {
        		return Objects.hash(lineNum, prefix, areaCode);
        }
        ```


- 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기보다는 캐싱하는 방식을 고려해야 한다
    - 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해둬야 한다.
- 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.

  → 속도야 빨라지겠지만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다.


- **hashCode**가 반환하는 값의 생성 규칙을 API 사용자에 게 자세히 공표하지 말자.
    - 그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.