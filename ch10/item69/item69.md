# item 69

## 🚫 예외는 진짜 예외 상황에만 사용하라

---

아래의 코드는 예외를 `완전히 잘못 사용`한 예이다.

```java
try {
		int i = 0;
		while(true)
				range[i++].climb();
} catch (ArraylndexOutOfBoundsException e) {
		// 배열 끝 도달 시 예외 발생 → 반복 종료
}
```

표준적인 관용구대로 작성한 정상적인 코드는 아래와 같다.

```java
for (Mountain m : range)
    m.climb();
```

🤔 무엇이 문제일까?

→ 먼저 직관적이지 못하다.

그리고,

1. ***예외는 예외 상황을 위한 매커니즘이다.***

    이 말이 무슨 말이냐면,
    → 예외는 `예상치 못한 문제`를 처리하기 위한 구조다.
    정상적인 로직(반복 종료 등)을 예외로 처리하면, JVM은 그 상황을 최적화하지 않는다.
    즉, 불필요하게 느리고 비효율적이다.

2. ***try-catch 안의 코드는 JVM 최적화가 제한된다***

    → 예외 블록 안의 코드는 `JIT 컴파일러의 성능 최적화` 대상에서 일부 제외된다.
    따라서 일반적인 for 루프보다 더 느려진다.
    책에서는 100개짜리 배열을 사용했을 때, 2배 정도 느려졌다고 한다.

3. ***배열 반복문은 이미 경계 검사를 최적화한다***

    *→* 자바 컴파일러 / JVM은 배열 범위 검사 중복을 자동으로 제거한다.
    따라서 “중복 검사 제거로 성능 향상” 같은 이유는 잘못된 가정이다.


✏️ 또한, 반복문의 몸체에서 호출한 메서드가 내부에서 관련 없는 배열을 쓰다가 ArraylndexOutOfBoundsException을 일으켰다고 해보자.

→ 표준 관용구였다면, 예외는 잡지 않고 스택 정보는 남기며 `스레드를 즉각 종료`시킬 것이다.

→ 그러나, 예외를 사용할 경우, 스레드가 종료되지 않고 `반복문이 끝난 정상적인 상황`으로 착각하게 될 것이다.
즉, 버그가 숨겨져서 디버깅이 훨씬 어려워진다.

🤠 즉, 무슨 말이냐

> 예외는 오직 예외 상황에서만 쓰자.
절대로 일상적인 제어 흐름용으로 쓰지 마라.
>

표준적이고 쉽게 이해되는 관용구를 사용하자.
→ 성능 개선을 위한 이것저것 영리한 기법 속에서도 미묘한 버그와 어려워진 유지보수가 더 크다.

이는 API에도 적용된다.

> 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다
>

상태 의존적 메서드( 어떤 메서드가 특정 상태에서만 호출 가능한 경우 )에는 상태 검사 메서드가 필요하다.
ex) Iterator

| **구분** | **역할** |
| --- | --- |
| hasNext() | 다음 요소가 있는지 **상태 검사** |
| next() | 다음 요소를 **가져오는** (상태 의존적) 메서드 |

```java
// 덕분에 이런 코드가 가능하다.

for (Iterator<Foo> i = collection.iterator(); i.hasNext();) {
    Foo foo = i.next();
}
```

```java
// 즉, 이런 식으로 코드를 작성하지 말자

try {
    Iterator<Foo> i = collection.iterator();
    while (true) {
        Foo foo = i.next();
    }
} catch (NoSuchElementException e) {
    // 끝까지 도달
}
```

이런 상태 검사 메서드 대신 다른 선택지도 존재한다.

→ 올바르지 않은 상태일 때 빈 옵셔널 혹은 null 같은 특수한 값을 반환하는 방법이다.

- 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침
    1. 외부 동기화 없이 `여러 스레드가 동시에 접근`할 수 있거나 `외부 요인으로 상태가 변할 수 있다면`,
    → 옵셔널이나 특정 값을 사용한다.
        - 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다.

    2. `성능이 중요한 상황`에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 `중복 수행`한다면,
    → 옵셔널이나 특정 값을 선택한다.


    3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 낫다고 할 수 있다.
    → 가독성 👍🏻
    → 발견하기 쉽고 👍🏻
    → 상태 검사를 잊을 경우, 예외를 던져 버그를 확연히 드러냄 👍🏻
        (반면, 특정 값은 검사하지 않고 지나쳐도 발견이 어렵다)
        ( ex: Null, Blank Collection … )

### 📁 정리

예외는 예외 상황에서만 사용하고,
정상적인 제어 흐름에서 사용하지 말아라