# item 82

## 🦺 스레드 안전성 수준을 문서화하라

---

> 한 메서드를 여러 스레드가 동시에 호출할 때
그 메서드가 어떻게 동작하느냐는 해당 클래스와 이를 사용하는 클라이언트 사이의 중요한 계약과 같다
>

🤔 synchronized 한정자가 보이는 메서드는 스레드 안전하다?
→ 이는 몇 가지 측면에서 틀렸다.

1. 메서드 선언에 **synchronized** 한정자를 선언할지는 구현 이슈일 뿐 **API**에 속하지 않는다.
   → 즉, 자바독이 기본 옵션에서 생성한 API 문서에는 포함되지 않는다.
2. 스레드 안전성에도 수준이 나뉜다.
   → 멀티스레드 환경에서도 API를 안전하게 사용하게 하려면
   클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다

🛟 스레드 안정성 (높은 순)

1. ***불변 (immutable) :***
   → 마치 상수와 같다, 외부 동기화도 필요하지 않다.
   ex) String, Long, Biglnteger

2. ***무조건적 스레드 안전 (unconditionally thread-safe) :***
   → 인스턴스는 수정될 수 있으나,
   내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다.
   ex) AtomicLong, ConcurrentHashMap

3. ***조건부 스레드 안전 (conditionally thread-safe) :***
   → 무조건적 스레드 안전과 같으나,
   일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다.
   ex) Collections.synchronized 래퍼 메서드가 반환한 컬렉션들

4. ***스레드 안전하지 않음(not thread-safe) :***
   → 인스턴스는 수정될 수 있으며,
   동시에 사용하려면 각각의 메서드 호출을 외부 동기화 메커니즘으로 감싸야 한다.
   ex) ArrayList, HashMap 같은 기본 컬렉션

5. ***스레드 적대적(thread-hostile) :***
   → 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.
   → 이런 메서드는 재배포 or 사용 자제 API로 지정한다.

📦 위 분류는 스레드 안전성 애너테이션
(@Immutable, @ThreadSafe, @NotThreadSafe)과 대략 일치한다.
→ 앞 분류의 무조건적 스레드 안전과 조건부 스레드 안전은 모두 @ThreadSafe 애너테이션 밑에 속한다.

**조건부 스레드 안전한 클래스**는
어떤 순서에서 외부 동기화가 필요한지, 어떤 락을 얻어야하는 지를 알려줘야한다.

→ 일반적으로는 인스턴스 자체를 락으로 얻는다.

BUT, 예외가 존재한다.
→ 🔎 Collections.synchronizedMap의 API 문서를 살펴보자

```java
synchronizedMap이 반환한 맵의 컬렉션 뷰를 순회하려면 반드시 그 맵을 락으로 사용해
수동으로 동기화하라.

Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
Set<K> s = m.keySet(); // 동기화 블록 밖에 있어도 된다.
	...
synchronized(m) { // s가 아닌 m을 사용해 동기화해야 한다!
		for (K key : s)
				key.f();
}

이대로 따르지 않으면 동작을 예측할 수 없다.
```

→ synchronized() 에 s가 아닌 m을 사용해야하는 이유

> s는 m의 데이터를 공유한다.
즉, synchronized(s)로 하면 맵 내부의 실제 락과 다르기 때문에 동기화가 깨진다.
****
올바른 락은 **맵 자체(m)** 이어야 한다.
→ 그래야 m과 s 둘 다 같은 내부 락에 의해 보호된다.
>

- 특징

  클래스의 스레드 안전성은 보통 클래스의 문서화 주석에 기재하지만,
  독특한 메서드라면 해당 메서드의 주석에 기재하라

  열거 타입은 굳이 불변이라고 쓰지 않아도 된다.
  반환 타입만으로는 명확히 알 수 없는 정적 팩터리라면 반환하는 객체의 스레드 안전성을 문서화 해라 ‼️


### **🔒 클래스가 외부에 락을 제공할 때**

**👍🏻 장점**

- **원자적 연산 가능**

  외부(클라이언트)에서 락을 직접 사용할 수 있으므로,
  여러 메서드 호출을 **하나의 원자적 동작**으로 묶어 실행할 수 있다.


**👎🏻 단점**

- **내부 동시성 제어와 충돌**
    - 클래스 내부에서 사용하는 고성능 동시성 메커니즘(ex: ConcurrentHashMap의 내부 락 구조)과 **혼용이 불가능**하다.
    - 즉, 내부 동시성 최적화를 **포기해야 한다.**
- 서**비스 거부(DoS) 위험**
    - 외부에서 락을 오래 쥐고 있으면, 다른 스레드들이 접근하지 못해
      **서비스 거부 공격(denial-of-service)** 상황이 발생할 수 있다

🤔 이때, 서비스 거부 공격을 막으려면 어떻게 해야할까?

→ synchronized 메서드 대신 비공개 락 객체를 사용해야 한다.

```java
코드 82-1 비공개 락객체 관용구 - 서비스 거부 공격을 막아준다.
private final Object lock = new Object();

public void foo() {
		synchronized(lock) {
				...
		}
}
```

비공개 락 객체는 클래스 바깥에서는 볼 수 없으니 클라이언트가 그 객체의 동기화에 관여 할 수 없다.

→ 락 객체를 동기화 대상 객체 안으로 캡슐화한 것이다.

📝 위의 코드 예시와 같이 **락 필드는 항상 final로 선언**하라.
→ 락 객체가 교체되는 일을 예방해준다.
→ 락 필드의 변경 가능성 최소화

비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에서만 사용할 수 있다.

❌ 조건부 스레드 안전 클래스에서는 특정 호출 순서에 필요한 락이 무엇인지를 클라이언트에게 알려줘야 하므로 이 관용구를 사용할 수 없다.

### **🔐 비공개 락 객체 관용구의 필요성**

**✅ 상속용 클래스에서는 특히 중요**

- 클래스 내부에서 **자신의 인스턴스를 락으로 사용**하면,
  하위 클래스가 **같은 락을 다른 목적으로 사용할 가능성**이 생긴다.

**⛔️ 문제점**

- **상호 간섭 위험**
    - 하위 클래스와 상위 클래스가 같은 락을 공유하면,
      서로의 동작이 **의도치 않게 방해** 받을 수 있다.
    - 즉, 상호 간의 **교착(deadlock)** 또는 **성능 저하** 위험이 있다.

  → 이는, 실제로 **Thread 클래스에서 발생한 문제**로 알려져있다.


### 📁 결론

- 모든 클래스는 자신의 스레드 안전성을 문서화 해야한다.