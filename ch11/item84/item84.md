# 아이템 84

## 프로그램의 동작을 스레드 스케줄러에 기대지 말라

**스레드 스케줄러**

- 여러 스레드가 실행 중일 때 운영체제가 어떤 스레드를 얼마나 오래 실행할지 결정하는 구성 요소
- 정상적인 운영체제라면 이 작업을 공정하게 수행하지만, 구체적인 스케줄링 정책은 운영체제마다 다를 수 있음

**문제점**

- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램은 다른 플랫폼에 이식하기 어려움
- 운영체제마다 스케줄링 정책이 다르기 때문에 동일한 코드가 다른 환경에서 다르게 동작할 수 있다

### **스케줄러에 의존하지 않는 구조 만들기**

**1. 실행 가능한 스레드 수 관리**

- 실행 가능한 스레드 수가 프로세서 수보다 많지 않게 유지
- 실행 가능한 스레드가 너무 많으면 스케줄러가 스레드 전환(context switching)을 너무 자주 수행해야 함(스레드 전환은 **CPU 캐시를 비우고 다시 채우는 비용**)
- 스레드는 할 일이 있을 때만 실행되고, 일이 끝나면 wait 하도록 설계

**2. Executor Framework 활용**

- 스레드 풀 크기 설정 : CPU 수와 작업 특성(입출력 중심인지, 계산 중심인지)에 맞게 설정
- 작업 크기 조절
    - 작업은 짧게 유지하는 것을 지향
    - 너무 짧으면 안 됨. 작업을 분배하는 부담이 오히려 성능을 떨어뜨릴 수 있습니
    - 적절한 균형을 찾는 것이 중요

**3.바쁜 대기(Busy Waiting) 금지**

- 조건이 만족될 때까지 쉬지 않고 반복 검사하는 방식

```java
while (true) {
    synchronized (this) {
        if (count == 0)
            return;
    }
}
```

**문제점**

- CPU를 쉴 틈 없이 사용 → 전력 낭비
- 다른 유용한 작업이 CPU를 못 씀
- 스케줄러 정책에 따라 성능이 심하게 변동
- 시스템 전체 성능 저하

**해결**

`wait()`, `notify()`, `notifyAll()` 사용
`java.util.concurrent` 패키지의 동시성 유틸리티 활용

### **피해야 할 것들**

**1.Thread.yield() 사용 금지**

- 현재 스레드가 “나 조금 쉴게요”라고 스케줄러에 힌트를 주는 메서드
하지만 보장 x
- 이식성이 없습니다 : • JVM마다, OS마다 동작이 다름
- 테스트할 수단x : 동작이 JVM 구현에 따라 달라지므로 일관된 테스트가 불가능
- 근본 문제 해결 X

올바른 해결책

- 작업 큐 사용
- Producer-Consumer 패턴 적용
- 스레드 풀 크기 조정
- 비동기 처리 방식 도입

**2.스레드 우선순위 조절의 위험성**

- 자바에서 스레드에 우선순위를 설정하여 스케줄러에게 힌트를 제공
- 자바에서 가장 이식성 낮은 기능
- OS별로 우선순위 매핑이 다르고,어떤 시스템에서는 아예 무시
- 디버깅이 어렵움

### **실전 가이드라인**

**1.설계 단계**

- 스레드 협력 방식 정의
- 권장 방법 : 공유 상태 최소화, 불변 객체, 스레드 안전한 자료구조

**구현 단계**

- `java.util.concurrent` 패키지의 고수준 유틸리티 활용
- CountDownLatch, Semaphore, CyclicBarrier 등 사용
- ExecutorService로 스레드 관리

**3. 최적화 단계**

- 먼저 올바르게 동작하도록 만들기
- 실제 병목 지점 파악
- 구조적 개선으로 문제 해결
- Thread.yield()나 우선순위는 최후의 수단으로만 고려

**4. 테스트 단계**

- 다양한 환경 검증
- 부하 테스트 수행
- 경쟁 조건 검증
- 여러 JVM 구현에서 확인