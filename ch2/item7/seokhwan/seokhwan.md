# Item 7

추가 일시: 2025년 9월 5일 오후 5:27
강의: Effective JAVA

## 🍀 Item 7: 다 쓴 객체 참조를 해제하라

---

해당 Item을 보며 느낀 의식의 흐름이다.

> C, C++ 처럼 메모리를 직접 관리해야 하는 언어를 쓰다가 자바처럼 GC를 갖춘 언어를 사용하면 편하다.
> 

→ 맞다. C, C++에서는 malloc으로 할당한 메모리를 free(), delete와 같이 메모리를 해제해야 하는데, Java는 GC가 알아서 다 해주니 편하다.

> 그래서 자칫 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 오해할 수 있는데, 절대 사실이 아니다. 메모리 누수가 발생 할 수 있다.
> 

→ ❓❓❓ GC가 알아서 다 해주는거 아니었나, 분명 Java의 장점으로 알고 있었는데❓❓❓ 

✅ **Garbage Collection이란?**

JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 사용하지 않는 메모리 객체를 제거하는 과정을 대신 수행해준다.

그렇다면 사용하지 않는 메모리 객체에 대한 기준이 무엇인가?

‘객체가 참조되지 않는 상태의 메모리’ 이다.

즉, 더 이상 사용하지 않는 객체라 하더라도 참조하는 객체가 있다면 GC가 메모리를 회수하지 않는다.

**메모리 누수가 발생하는 상황**

```java
//stack 코드 생략
public Object pop() {
	if (size == 0) throw new EmptyStackException();
	return elements[--size];
}
```

관심있게 코드를 살펴보지 않는다면 그냥 넘어갈 수 있는 코드이다.

```java
elements[size] = null;
```

하지만 다음과 같은 코드가 없다면 GC는 해당 메모리 영역을 회수하지 않는다.

개발자는 pop을 하면 해당 영역의 메모리는 사용하지 않는다고 생각하지만, GC의 입장에서 size에 해당하는 메모리 영역은 해제되지 않은 참조영역으로 인식한다.

다 쓴 객체 참조를 null로 처리하면, 이후 해당 참조를 실수로 사용할 때 NullPointerException을 던져 프로그램의 오류를 조기에 발견할 수 있다는 장점도 따라온다.

다 쓴 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다.

**캐시로 인한 메모리 누수**

```java
User user = new User("user1", "사용자이름", "email")
cache.put(user, "data");
user.setId("user1_updated");
String data = cache.get(user); //null 반환 
```

다음과 같이 키값이 변하면 엔티티의 hash값이 변경되어 기존 데이터는 고아 객체가 되어 캐시에 남아있게된다. 즉, 메모리 누수가 발생한다.

이를 해결하기 위한 몇가지 방법이 있다.

1. 불변키를 사용하여 메모리 누수가 발생하지 않도록한다.
2. WeakHashMap을 사용한다.

**WeakHashMap 사용**

```java
WeakHashMap<User, String> cache = new WeakHashMap<>();
User user = new User("user1", "사용자이름", "email")
cache.put(user, "data");
user.setId("user1_updated");
user = null; // 외부 참조 제거

System.gc(); // GC 실행 시 자동으로 캐시에서 제거됨!
```

다음과 같이 약한 참조를 사용하는 WeakHashMap을 사용하면 키가 null이 되었을 때 GC가 자동으로 정리하게 된다.

캐시를 만들 때 보통 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기 때문에 시간에 따른 가치 전략을 사용한다. 해당 방식에서는 쓰지 않는 엔트리를 정리해주어야 한다.

**리스터(listener)와 콜백(callback)으로 인한 누수**

리스너: 특정 이벤트가 발생했을 때 자동으로 호출되는 객체 혹은 메서드

콜백: 다른 함수에 인자로 전달되어, 특정 시점에 다시 호출되는 함수

리스너나 콜백은 다른 객체로 인해 동작이 실행되기 때문에 더 큰 객체를 참조하고 있는 경우가 많다.

때문에 리스너나 콜백의 해제를 명확하게 해지하지 않는다면, 큰 객체도 함께 메모리에 잔존하여 연쇄적인 메모리 누수가 발생하게 된다.

때문에 이를 약한 참조로 저장하여 참조로 젖 GC가 이를 수거할 수 있도록 하여야한다.